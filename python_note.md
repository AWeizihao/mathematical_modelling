# Python 学习笔记

这里是我学py的时候记的笔记。
+ 可以无视turtle模块部分；
+ “序列”部分对**列表**有较好的掌握即可，字典可以跳过
+ “类”是python等面向对象语言的灵魂，掌握概念是有好处的。可以先对类和对象有一个初步了解
+ 作为前置知识，“列表”就是其他语言内数组的概念，表示为 `[1, 2, 3]` 或者 `1, 2, 3`
+ 迭代器和生成器是python特有的非常强大的工具，不过完全可以用循环和递归代替，可以跳过。python的for循环实际上非常慢，远远慢于cpp的for，所以在追求高性能时使用迭代器等会更优。
+ 异常捕获有兴趣可以看
+ 特殊方法部分非常装逼，可以了解。

## 1 基本知识
+ 1.1 **求余**（mod）用 % 算符。例如`1 % 2` ,结果是 1 。
      x % y 其实是等价于 ` x - ((x // y) * y)`。
+ 1.2 **整除** 用双斜杠 // 算符。 返回值是**向下取整**的整数。
+ 1.3 求余和整除都可以用于负数甚至浮点数。例如：
  ``` python
  2.75 % 0.5　　　　　　　　　10 // -3 
  > 0.25　　　　　　　　　　　 > -4

  10 % -3　　　　　　　　　　 -10 // 3
  > -2　　　　　　　　　　　　　> -4

  -10 % 3　　　　　　　　　　 -10 //3 -3
  > 2　　　　　　　　　　　　　> 3

  -10 % -3
  > -1
  ```
  对于整除运算，只要记住它是向下圆整，所以结果如果是负数那么将会离零更远。然后根据整除的结果计算余数。
+ 1.4 **乘方** 用双乘号 ** 算符。例如，`2 ** 3 `结果是 8 。乘方也可以用内置函数 pow 来实现。例如，`pow(2,3)`结果也是 8 。
+ 1.5 **开方** 将 1.4 里的乘方次数变成相应的小数即可 。开平方也可以用 sqrt 函数。
+ 1.6 **绝对值** 用内置的abs函数
+ 1.7 **取整** 用内置函数 round 。round并不是向下取整的，round会**取与之最接近的整数**，如果一样接近（如1.5），那就会取偶数。
  　　如果要向下取整，要用到 math 模块的 floor 函数（详见下）。
  　　如果要向上取整，则用 math 模块里的 ceil 函数。
+ 1.8 **赋值** python的变量不需要预先声明，也因此所有变量必须赋值，因为python不提供默认值。赋值直接等号连接即可，例如，将 3 赋给变量 x ：`x = 3`。
  更高等级的赋值技巧有（要用到后面的知识）：
  - 1.8.1 **并行赋值** 
    ```python
    >>> x,y,z=1,2,3 
    >>> x
    1
    >>> y
    2
    >>>z
    3
    ```
  - 1.8.2 **序列解包(unpack)** 用序列（可以是列表元组字典等）赋值。
     ```python
     value=1,2,3
     x,y,z=value
     print(x,y,z)

     > 1 2 3

     dic={'nope':'no','yep':'yes'}
     a,b=dic.popitem() #随机取一项，随后在字典里删除这一项
     print(a,b)

     > 'nope' 'no'
     ```
  - 1.8.3 ***算符**
   众所周知，在1.8.2里用的序列解包都是需要两边数量一样才能执行。但是，可以用 * 算符来收集多余的值。例如：
    ```python
    a,b,*rest = [1,2,3,4]
    print(rest)
   
    > [3,4]
    ```
    *元素不一定要放在最后一位。带有 * 号的默认是一个列表，无论有几个元素。对于字符串，这样赋值也是可以的：
    ```python
    a,*b,c = '1234'
    print(a,b,c)

    > '1' ['2','3'] '4'
    ```
  - 1.8.4 **快速交换** 
    ```python
    x,y = y,x
    ```
  - 1.8.5 **链式赋值**
   将多个变量关联到一个值。其中一个改变其他都会改变，因为本质上是一个变量。
    ```python
    x=y='123'
    ```
    这就把'123'同时赋给x和y。

  - 1.8.6 **增强赋值**
    如果要实现累加，可以写`x=x+1`,或者是`x += 1 `。这种写法不一定只是加1，可以加任何数字，甚至适用于所有标准运算符。



+ 1.9 **输出** 用函数 print 。print 的参数并不限于字符串，可以是变量、字符串以及表达式。比如 print(2 * 3) 也是允许的，会输出 6 。print允许多个参数，它将把所有参数输出。还可以自定义分隔符。
+ 1.10 **输入** 用函数 input 。input的参数是一个字符串，是显示在用户界面的获取输入的引导词。例如，`input("what's your name?")`,会在界面上显示出what's your name?，然后等待输入，输入以回车结束。  
input函数的返回值是用户的输入内容。可以单独使用input函数，也可以把input的返回值赋给某个变量，如，`x = input("name?")`,那么获取的用户输入最后会被储存到变量 x 中（严格来说会被存在电脑内存里，x 只是指向这个值）。
+ 1.11 **模块**
  - 1.11.1 模块导入用到的是 import 命令。这个命令有两种格式(以math 模块为例）：
  ```python
  import math
  math.floor(3.14)

  from math import floor
  floor(3.14)
  ```
  两者的结果都是 3
  后者只导入了floor这一个函数
  - 1.11.2 **如果导入整个模块，那么模块中函数调用要加模块名前缀。**
  不同模块中可能包含同名函数，所以遇到这种情况时只能用 from 的格式。
  但是，例如复数模块cmath中的sqrt和math里的sqrt是冲突的，当导入了cmath模块，就不能正常使用math的sqrt了。所以非必要情况都用import的一般格式。
  - 1.11.2 可以通过用变量来引用函数（以及其他大部分Python元素）。例如，`foo = math.sqrt`用foo代替了sqrt函数，就可以用foo来计算平方根，如foo(4) = 2.0
  - 1.11.3 **模块cmath**（复数）
     * 1.11.3.1 复数sqrt与实数sqrt区别：math中的sqrt会返回实的**浮点数**，而cmath的sqrt返回复数（**虚数单位用j表示**）。如：
    ```python
     import math
     math.sqrt(4)
     >>>2.0

     import cmath
     cmath.sqrt(4)
     >>>2+0j
    ```
    * 1.11.3.2 在cmath下，python支持复数运算。如（1+1j）*（2+3j）能够得到正确结果。
  - 1.11.4 **模块turtle**
    * 1.11.4.1 海龟模块可以绘制基本的图形。“海龟”源于海龟机器人，可以向各个方向旋转，爬行和绘制（这种机器人有带笔，可以选择放下或者提起）。
    * 1.11.4.2 基本命令如下
    ```python
    turtle.forward(长度) 往前移动
    turtle.backward(长度) 往后移动
    turtle.right(角度) 顺时针转
    turtle.left(角度) 逆时针转
    turtle.pendown() 下笔
    turtle.goto(x,y) 跳到这个坐标
    turtle.penup() 提笔
    turtle.width(宽度) 线条宽度
    turtle.circle(半径，角度) 以当前坐标为起点进行逆时针画圆，注意在这里这个当前坐标并不是圆的圆心。第二个参数为圆心角。
    turtle.color(颜色)（要用字符串格式，如turtle.color("red"))
    ```
    * 1.11.4.3 知乎高人画奥运五环代码：
    ``` python
    import turtle

    turtle.width(10)
    #第一环
    turtle.color("blue")
    turtle.circle(50)
    #第二环
    turtle.penup()
    turtle.goto(120,0)
    turtle.pendown()

    turtle.color("black")
    turtle.circle(50)
    #第三环
    turtle.penup()
    turtle.goto(240,0)
    turtle.pendown()

    turtle.color("red")
    turtle.circle(50)
    #第四环
    turtle.penup()
    turtle.goto(60,-50)
    turtle.pendown()

    turtle.color("yellow")
    turtle.circle(50)
    #第五环
    turtle.penup()
    turtle.goto(180,-50)
    turtle.pendown()

    turtle.color("green")
    turtle.circle(50) 
    ```
    * 1.11.4.5 安装模块我们一般使用命令pip3 install （模块名）。但是在命令行输入后可能会遇到安装报错的问题，如果末尾有说明（This is an issue with the package mentioned above, not pip.）说明问题不是出在pip而是出在安装包。根据返回结果提示，可以发现问题出在安装包里setup.py文件的第40行。https://files.pythonhosted.org/packages/ff/f0/21a42e9e424d24bdd0e509d5ed3c7dfb8f47d962d9c044dba903b0b4a26f/turtle-0.0.2.tar.gz 在此网址下载win版turtle安装包（暂不知linux是否可用），解压后找到setup.py,显然是python文件，我们用vscode打开，发现line40是 `except ValueError, ve:`，这是python2的语法，在python3应该改成`except (ValueError, ve):`，然后右键选close saved关闭。然后唤出命令行，`pip3 install -e +路径`。路径是turtle包解压后的地址，地址到文件夹结束。回车即可安装。
  - 1.11.5 time模块
    time模块包含一下常用函数：
    ```python
    time.time() 返回现在的时间，精度较低
    time.perf_counter() 返回高精度的时间，可以用来测量短时间的值，比如程序的执行时间。
    time.process_time() 返回当前进程的系统和用户CPU时间总和的值（以小数秒为单位）
    time.sleep() 暂停执行调用线程达到给定的秒数。需要注意的是：参数可以是浮点类型，也就是说，时间可以精确到毫秒级。
    ```
+ 1.12 **pip安装指南**。pip是python第三方库的下载器，在下载python解释器时都默认安装。在dos界面输入`pip --version`可查看pip文件存放路径和版本。但是每次都要输入那个地址才能打开pip比较麻烦，所以选择把pip放到环境变量里面。环境变量的作用是电脑在本文件夹找不到某个文件时会去环境变量上的地址寻找。win10中 win+R打开运行，然后输入control，回车就会出现类似win7的控制面板界面。选择系统和安全-系统-高级系统设置，选择环境变量-系统变量，新建，然后把pip所在文件夹复制进去即可。pip文件默认存放在C:\Users\Administrator\AppData\Local\Programs\Python\Python310\Scripts 其中Administrator为用户名，appdata为隐藏文件夹。

## 2 序列
  序列可以是列表、元组、字符串等等。
+ 2.1 **序列基本操作**
  - 2.1.1 **索引(indexing)**：一个序列的每个元素都有编号，从**零**开始递增,编号0指向第一个位置。索引是利用编号来访问序列这个编号下的元素。格式是在序列名后加方括号，方括号里是索引编号。索引的结果是这个编号指向的元素值。例如：
    ```python
    a = "Hello"
    print(a[0])
    
    >>>H
    ```
    字符串就是由单个字符构成的序列。
    索引的编号可以是负数，此时将从序列的右端开始数，如a[-1]就指向序列a的最后一个位置，即a[-1]="o"。
    注意，方括号前面不一定是一个变量，也可能直接是字符串等等。如下都是可行而方便的方式：
    ```python
    >>>"Hello"[1]
    e
    
    b = input('name:')[1]
    ```
  - 2.1.2 **切片(slicing)**:索引用于访问单个元素，切片用于访问一个范围内的元素。切片的结果是一个序列。
    * 2.1.2.1 切片的格式就是把索引方括号里的数字改为范围。范围的上下界用冒号分隔。**下界包含而上界不包含**。例如`a[1:3]`，就指向a序列的第二和三个元素(a[1]和a[2])。
    * 2.1.2.2 和索引一样，切片的编号也可以是负的,原则就是**前一个索引指定的元素不能位于第二个索引指定的元素的后面**，例如`a[-3:0]`就会返回一个空序列。
    `a[-3:-1]`表示倒数第二、倒数第三两个元素。可见，这无法表示最后一个元素，因为编号0指向左边第一个。
    * 2.2.2.3 如果一个切片要包含最后一个元素，就采用空出上界的办法，如`a[-3:]`。
     同样，要包含开头，也可以省略0，写作`a[:3]`,这就表示a[0]、a[1]和a[2]。
     如果要表示整个序列，则上下界都可以省略：`a[:]`即表示整个序列。
  - 2.1.3 **步长(step)**：一般默认步长为1，也就是从一个元素移到下一个元素。
    * 2.1.3.1 步长标示在切片的两个索引后面，用冒号与它们隔开。例如，步长为1就可以写成`a[0:3:1]`。一般步长为1时步长可以省略。步长的标注不影响上述的简写，例如`a[::2]`也是可以的。
    * 2.1.3.2 步长不能为0，但是可以是负数。负数表示从右往左提取元素。如：
      ```python
      >>>"python"[4:2:-1]
      [o,h,t] 
     
      >>>"python"[2:4:-1]
      []
      ```
      第二个例子说明，步长为负时第一个索引必须比第二个索引大。但是也有例外，那就是省略索引时，例如`a[2::-2]` `a[:5:-2]`都能正确地从后向前取。
  - 2.1.4 **加法** 用于拼接序列,用“+”表示。例如：
    ```python
    >>>[1,2,3]+[4,5,6]
    [1,2,3,4,5,6]

    "hello,"+"world"
    >>> "hello,world"
    ```  
  - 2.1.5 **乘法** 用于重复序列。当序列与x相乘是，将重复这个序列x次来创建一个新序列：
    ```python
    >>>"python" * 2
    "pythonpython"

    >>>[1,2,3] * 2
    [1,2,3,1,2,3]
    ```
  - 2.1.5’ 空列表
      空列表用[]表示。列表元素的值也可以是“什么也没有”，用None表示。`[None] * 10`就创建了一个空的、初始化长度为10的列表。
  - 2.1.6 **成员资格(in)** ：检查一个值是否在序列中。例如：
    ```python
    >>>permissions = "rw"
    >>>"w" in permissions
    True

    >>>users = ["mlh","foo","bar"]
    >>>input("enter your name:") in users
    enter your name: mlh
    True
    ```
  - 2.1.7 函数len返回序列的元素个数（长度）。 
          函数max和min分别返回序列的最大、最小值。
+ 2.2 **列表**    
  - 2.2.1 从字符串到列表：用list，例如：
    ```python
    >>>list("hello")
    ["h","e","l","l","o"]
    ```
   - 2.2.2 赋值 
      * 2.2.2.1给列表单个元素赋值，如`a[2] = 4`
      * 2.2.2.2给列表的一段切片赋值，可以修改长度。例如：
        ```python
        >>>name=list("perl")
        >>>name[1:]=list("ython")
        >>>name
        ["p","y","t","h","o","n"]
        ```
        使用切片赋值还可以插入元素：
        ```python
        >>>name=list("pthon")
        >>>name[1:1]="y"
        >>>name
        ["p","y","t","h","o","n"]
        ```
        切片赋值也可以删除元素，如`name[1:2]=[]`就删除了name列表第2个元素。
        切片赋值的步长也可以修改，甚至可以是负数（注意如果步长不为1，那么切片赋值需要等长）。
   - 2.2.2 删除 如，`del a[2]`就删除了a[2]这一项，而且减少了列表的长度。
   - 2.2.3 **append方法**
     **方法append用于将一个对象加到列表末尾**。append是一个方法而不是函数，它没有返回值，也就是说它修改原列表，而不是生成一个新列表。
     ```python
     >>>lst=[1,2,3]
     >>>lst.append(4)
     >>>lst
     [1,2,3,4] 
     ```
   - 2.2.4 **clear方法**
     **方法clear就地清空列表内容，没有返回值**。列表将变为[]。clear方法虽然不加参数，但是不能省略括号。必须写作如a.clear()的样式,这一点适用于所有函数和方法。
   - 2.2.5 **copy方法**
     copy复制列表。常规复制是将两个列表关联，实际上指向同一个列表，如：
     ```python
     >>>a=[1,2,3]
     >>>b=a
     >>>b[1]=2
     >>>a
     [2,2,3]
     ```
     而copy复制则不关联两个列表：
     ```python
     >>>a=[1,2,3]
     >>>b=a.copy()
     >>>b[1]=2
     >>>a
     [2,2,3]
     ```  
   - 2.2.5 **count方法**
     计算指定元素在列表中的出现次数。
   - 2.2.6 **extend方法**
     将另一个列表加到此列表后面，没有返回值，比如`a.extend(b)`就是把b列表附到a列表后面。效率要高于直接拼接。
   - 2.2.7 **index方法**
     **方法index在列表中查找指定值第一次出现的地方的索引**。参数为要找的值。如果找不到会**报错**。
   - 2.2.8 **insert方法**
     将一个对象插入到列表。如：
     ```python
     >>>a=[1,2,3,4,5]
     >>>a.insert(3,"four")
     >>>a
     [1,2,3,"four",4,5] 
     ```
   - 2.2.9 **pop方法**
    从列表删除一个元素（默认为最后一个元素），并返回这一元素。
     ```python
     a=[1,2,3,4]
     b=a.pop()
     print(b)
     print(a)

     > 4  [1,2,3]
     ``` 
     利用pop可以实现一种常见的数据结构——栈（stack）。栈的准则是**后进先出（LIFO）**。python里的另一个栈操作是append。append为栈加入一个元素。
   - 2.2.10 **remove方法**
     删除第一个为指定值的元素，没有返回值。
   - 2.2.11 **reserve方法**
     按相反的顺序排列列表中的元素。reserve修改列表但不返回任何值。  
     函数reserved与之类似，将列表反向，但是不返回列表，而是返回一个迭代器，可以用list函数把迭代器变为列表。例如：
     ```python
     x=[1,2,3]
     print(list(reserved(x)))

     > [3,2,1]
     ```
   - 2.2.12 **sort方法**
     sort方法把列表就地（升序）排序，没有返回值。
     相应的，有函数sorted，可以升序排序一个**序列**（这包括字符串等），但总返回一个列表。
     sort接受两个可选参数：key和reserve。key（键）为排序依据，例如可以写作`a.sort(key=len)`,表示把a列表按元素长度升序排序。而reserve参数则是布尔类型，ture表示降序，false表示升序（默认）。例如：`a.sort(key=len,reserve=True)`。注意python里true的t一定要大写（优秀的编译器会自动修改小写为大写，比如vscode+插件）。
     sorted函数也接受这两个参数。
+ 2.3 **元组**
  元组也是一种序列。元组与列表类似，但把方括号改为圆括号，或者没有括号，仅仅逗号分隔。例如，`(1,2,3)` `1,2,3` `()` `(1,)`都是元组。其中第三个为空元组，第四个元组仅一个元素,但是逗号不能省。
  **元组是不能修改的序列。**
  2.3.1 **函数tuple**
  tuple把**序列**变为元组。如果参数本身就是元组，就一模一样输出。
  2.3.2  元组的索引、切片等等，仍然使用方括号，如`a[1]`这样的样式也同样适用于元组。由于元组也是一种序列，所以适用于序列的操作（如索引、切片等）也一样适用于元组，但是不能赋值、删除等。

## 3 字符串
## 4 字典
+ 4.1 字典中，一个**键**对应一个**值**。字典用两个大括号表示，内容是一个个**键值对**，叫做项。每个项之间用逗号分隔，键值对里键和值用冒号分隔，举例如下：
  ```phonebook = {"Alice":"1234","Beth":"9120","Cecil":"3258"}```
  **字典属于映射。**
+ 4.2 **函数dict**
  dict函数从其他映射或者键值对序列创建字典,参数可以是序列、映射等，返回一个字典。用例如下：
  ```python
  >>>dict()                        # 创建空字典
  {}
  >>> dict(a='a', b='b', t='t')     # 传入关键字
  {'a': 'a', 'b': 'b', 't': 't'}
  >>> dict([('one', 1), ('two', 2), ('three', 3)])    # 可迭代对象方式来构造字典，使用元组
  {'three': 3, 'two': 2, 'one': 1}
  >>>
  ```
+ 4.3 **字典基本操作**
  - 4.3.1 **len(d)** 返回字典的项数
  - 4.3.2 **d[k]** 返回与k键关联的值
  - 4.3.3 **d[k]=v** 将v值关联到字典d中的k键，可以认为是赋值，但是这个字典操作可以创建一个新项，即k可以是原先没有的键，而在列表中这是不可以的，首先要创造空列表。
  - 4.3.4 **del d[k]** 删除**项**
  - 4.3.5 **k in d** 成员检查，d字典包含k键
+ 4.4 **注意：**
  - 4.4.1 字典键可以是任意类型，而且可以自由编辑。列表的键不光必须是整数，而且是按顺序自动生成的。
  - 4.4.2 要在字典中加入项，只要给一个新的键赋值就好。而列表不可以如此，除非使用append等方法，否则没法在列表中添加本来不存在的项。比如一个只有三项的列表lst，不可以用语句`lst[5]=1`。要能使用，必须事先`lst=[none]*6`。但是字典中只要直接赋值就可以创建新的键值对。
+ 4.5 **替换**
  类似字符串的format，字典拥有方法format_map。它的参数是字典。用例如下：
  ```python
     phonebook = {"Alice":"1234","Beth":"9120","Cecil":"3258"}
     print("cecil's phone number is {Cecil}".format_map(phonebook))

     > cecil's phone number is 3258
  ```
  不难看出，前面替换部分不加引号。
+ 4.6 **字典方法** 
  - 4.6.1 **clear方法** 清除字典，删除字典所有项。
    ```python
    x = {}
    y = x
    x[1] = 2
    print(y)
    x = {}
    print(y)

    > {1:2} {1:2}
    ```
    用赋一个空字典的方式来清空，不会修改关联的原字典。
    但是如果要同时也修改原字典，就要用clear。使用clear后，同时清空两个字典。
  - 4.6.2 **copy方法**
    返回一个一样的字典。规则是**当替换副本中的值时，原件不受影响；当修改副本中的值时，原价也跟着修改**。这样的复制叫**浅复制**。clear方法的示例中，y = x就是一种浅复制，后面将一个空字典赋给x，是替换操作，因而不影响原件。
    若要实现完全同步，就要用**深复制**，用copy模块里的deepcopy函数。
    **注意：调用copy和deepcopy后面的空括号不能省！！！**
  - 4.6.3 **fromkeys方法**
    创建一个新的空字典，只有键，没有值（None）。方法的参数为一个列表，里面的元素是键名。如果不要默认填充None，可以再加一个参数。
    可以对空字典用fromkeys方法，从而创建字典。例如：
    ```python
    >>> {}.fromkeys(['name','age'])
    {'age':None,'name':None}

    >>> dict().fromkeys(['name','age'])
    {'age':None,'name':None}

    >>> dict().fromkeys(['name','age'],'haha')
    {'age':'haha','name':'haha'}    
    ```
  - 4.6.4 **get**
    查询字典项。如果没找到会返回None而不是报错。get函数可以处理用户输入错误的情况。
    也可以不输出None而指定一个默认值，需要加一个参数。
    ```python
    d={}
    print(d['hahah']) 

    > Traceback (most recent call last):
        File "<stdin>", line 1, in?
      KeyError: 'hahah'
    
    d={}
    print(d.get('hahah'))
    
    >None

    d={}
    print(d.get('hahah','?'))
    
    >?
    ```
  - 4.6.5 **setdefault方法**
   在get方法功能的基础上，如果找不到这个项，则添加这个项。参数方法和get一模一样。
  - 4.6.6 **items方法**
   返回一个包含字典所有项的列表（？），每个元素都为（键，值）的形式。顺序排列是不一定的。返回值是一种**字典视图**的特殊类型。当然，可以用list函数将其转化为列表。
  - 4.6.7 keys方法
   返回包含字典所有键的字典视图。
  - 4.6.8 **pop方法**
   获取值并删除这项。
   ```python
   d={'1':1,'2':2}
   print(d.pop('1'))
   print(d)
   > 1
   > {'2':2}
   ```
  - 4.6.8 popitem方法 
   与列表里的pop相似，但是由于字典没有顺序，所以是随机删除一个项。没有参数。

## 5 条件和循环
+ 5.1 **if**
  - 5.1.1 **真值**
   以下均被认为是假(False):
   `False 　 None 　 0 　 ""  　()　  [] 　{}` 
   即空就是假。而非空（比如`1 (1,2) [1]`）等就都是真。True也是真。
   函数 **bool()** 能判断参数的真值，返回布尔值True或False
  - 5.1.2 if条件句格式
    ```python
    if *** :
        do something
    else:
        do something else
    ```
    冒号表示接下来是一个代码块。每一个代码块都需要严格缩进，缩进结束则表示代码块结束。
  - 5.1.3 **比较算符**
   
   | 表达式     | 描述     |
   | -------- | -------- | 
   | x == y | x等于y | 
   | x < y | x小于y | 
   | x >= y | x大于等于y | 
   | x != y| x不等于y|
   | x is y| x和y是同一个对象|
   | x is not y| x和y不是同一个对象|
   | x in y| x是y的成员|
   | x not in y| x不是y的成员|
   python支持**链式比较**，例如`10 < x < 19`是允许的。
   同样，python也有and、or、not算符，优先级也与其他语言一样。
  - 5.1.4 **elif**
  同vb中的else if 语句。 
+ 5.2 **断言**
  断言是为了程序在满足某一条件是可以终止。用到assrt语句。还可以在后面给出说明。
  ```python
  age=-10
  assert age > 0 ,'The age must be realustic'

  >Traceback (most recent call lst):
     File "<stin>", line 1, in ? 
   AssertionError: The age must be realustic
  ```
+ 5.2 **while循环**
  唯一需要注意的就是while加条件然后有冒号。缩进表示程序段，没有结束标志语。
+ 5.3 **for循环**
  - 5.3.1 for循环后加可迭代对象，迭代就是遍历。例如，可以加列表。**注意for也有冒号。**
    ```python
    num = [1,3,5,7,9]
    for i in num :
      print(i)
    ```
  - 5.3.2 **range()函数**
    range(a,b)能够创建从 a 到 b-1 的迭代器，用list函数可以把结果变成列表。包含开头不包含结尾的规则与切片slice是一样的。
    如果只输入一个参数，那么默认起始为0.
    ```python
    print(list(range(1,3)))
    > [1,2]

    print(list(range(2)))
    > [0,1]
    ```
    在for循环里用range非常方便，例如：
    ```python
    for number in range(1,101):
      print(number)
    ```
    上面的程序段会输出1-100.
  - 5.3.3 **用字典迭代**
    字典也是可迭代对象。


## 6 类 
+ 6.1 **对象**  对象大致意味着一系列数据（属性）以及一套访问和操作这些数据的方法。对象的优势如下：
   - **多态**  对不同类型的对象可以执行相同的操作。不用顾虑上游给出的数据形态。
   - **封装**  对外隐藏对象内部的工作原理，只留下几个**方法**作为端口（api），外界只能通过调用这个对象规定能用的方法来处理这个对象，而不能自己定义方法和函数来处理，也不能看到对象内部属性。
   - **继承** 可以在别处通用这个类的方法。
+ 6.2 **类**
  类就是指许多有相同点的对象的集合。其中任意一个对象就是一个实例。任何一个实例都有这个类的全部方法。
  **实例**就是调用类的产物，例如执行`a=Person()`以后，a就是Person类的一个实例了。
+ 6.3 **多态**  
  例如：
  ```python
  'abc'.count('a')
  [1,2,'a'].count('a')
  ```
  可见无需知道对象的类型就可以使用count方法。这就是多态的用例。
  rper函数也是多态函数，它的对象可以是任何东西。
+ 6.4 **封装**
  创建对象：
  ```python
  o = AObject()
  o.set_name('hahaha')
  print(o.get_name())
  
  hahaha
  ```
  上面的代码的内容是，假设**类**AObject已经定义，现在创建一个对象，把它关联到变量o，然后可以对它使用get_name等（随手写的）一系列方法（当然这些方法必须是AObject支持的）。
  &nbsp;
  封装的作用就是让类自己管理自己的属性。调用方法其实就是查看这个对象的属性。所谓自己管理，就是属性的值将保存在这个类自己的域内，而不是作为全局变量保存，这样只有调用特定的方法才可以修改这些属性。这样一来，就可以保证外部只能以我规定的方式查看和修改属性，从而保护封装的类和数据的安全。
+ 6.5 **自定义类**
  自定义类需要用到`class`语句。例如：
  ```python
  class Person:

    def set_name(self,name):
        self.name = name
    
    def get_name(self):
        return self.name
    
    def greet(self):
        print("Hello, world! I'm {}.".format(self.name))
  ```
  如上所示，Person是类的名字，然后为它定义了三个方法：set_name, get_name和greet。他们就是我们为这个类留的端口。
  &nbsp;
  - 6.5.1 self参数
  参量self指向对象本身。一般来说可以理解为它就指向这个类本身。但是严格来说，它其实指向实例。区别就在于，我们可以让两个变量分别指向同一个类，那么这时self就分别指向那两个变量了。
  这依旧与封装有关：
    ```python
    a = Person()
    b = Person()

    a.set_name('lihua')
    b.set_name('Paul')

    a.greet()
    b.greet()
    ```
    运行上面的程序就会发现，得到两个不一样的结果。这就是封装的效果，a和b这两个对象有自己的命名空间（域），所以互不影响。在运行`a.set_name('lihua')`时，就会把a作为第一个参数传递。
  &nbsp;
    self这个参数是必要的，但是其实不必一定叫self，它可以叫任何名字。不过，显然self是绝佳命名。但是无论叫什么，都不能省略这个参数。
    因此，我们也不可以直接对Person这个类做处理，例如`Person().setname('lala')`是不允许的，因为这样一来会把'lala'作为self参数传递出去，所以最后的报错会显示没有name属性。
    &nbsp;
   - 6.5.2 属性
   在上面的代码中，name就是类Person的一个属性。
   注意方法和属性的区别，它们的定义方式是一样的，方法是可以操作的，而属性就是静态的。例如：
   ```python
   class Person：
    def name(self):
        self.name = name

     def get_name(self)：
         return Person.name
    ```
    上面，name是属性，get_name是方法。属性的定义就是self.属性=……这样的形式。
   &nbsp;
   就严格的封装来说，应该是不允许外接直接访问属性的，必须通过特定的被定义者允许的方法去访问这个属性。比如，现在要实现用户在获取某个属性时发出蜂鸣警告，可以按照要求定义一个方法，但是如果用户能直接访问属性，那就根本不会触发警告。
   所以为了确保安全，不应允许外界访问属性。如同为面向对象的Smalltalk就是如此。但是在python里，依然可以直接访问属性。
   例如，`a.name`就可以得到储存在name里的字符串。
   &nbsp;
   Java为属性提供了四种不同的私密等级，而Python只有一个。
   要让外界不能直接访问属性，可以将属性设为私密。方法就是在给属性命名时在前面加两个下划线。
   例如，我们稍微修改上面的代码：
     ```python
     class Person:

      def set_name(self,name):
          self.__name = name
     
      def get_name(self):
          return self.name
    
      def greet(self):
          print("Hello, world! I'm {}.".format(self.name))

     a=Person()
     a.set_name('ll')
     print(a.__name)
     ```
      这样就会报错了，也就意味着不能访问这个私密属性。
    然而，这只是通过python在名称前自动加上前缀实现的，即原属性名变成了`_类名_属性名` 。例如，刚才的__name其实会被储存为_Person_name。
    所以知道了这个处理方法，依然可以访问私密属性。但是这就和隐藏文件一样，隐藏就说明不希望你能轻易地修改它，因为它可能是一个核心系统文件。
    - 6.5.3 变量
    在类里定义的变量，叫**类变量**，例如：
      ```python
      class Person:
          age = 20

          def new(self):
              self.name=name+'#'
      ```
      age就是类变量，而类里的每个实例都可以访问这个变量。
    而name就是实例变量，它在实例中被定义，比如在某一个实例a调用new方法时，name才会被定义和修改。
    &nbsp;
    注意，如果实例变量和类变量重名，那优先访问实例变量。例如：
      ```python
      class num:
          number = 6

      a=num()
      b=num()
      a.number=1
      print(num.number,b.number)
      ```
      上面的结果是6 6 
      这就说明，a.number=1实际上在实例a中创建了实例变量number，覆盖了类变量。

   - 6.5.4 **定义子类**
   类在定义时在后面加上括号和父类名就可以变成子类。
   在子类中可以改写父类的方法，如果不该写，就会默认继承父类的全部方法。
+ 6.6 **接口**
  在Java中，类显式地写明了它拥有哪些方法和属性，以便在编写不同部分时不用关系类的内部。然而Python并没有这样表明，编写者必须知道这个类有什么方法。
  整个类只依靠这几个方法与外界相连，这几个方法就是“接口”。
  - 6.6.1 hasattr()
  虽然python不会告诉我们某个类包含哪些接口，但是可以利用函数`hasattr()`来判断某一个方法是否包含在类里。
  格式是`hasattr(对象名，'方法名')`,结果为布尔形式。注意方法名必须是字符串。
  "attr"当为attribute的简写，意思是“属性”，当然，方法也囊括其中。
  - 6.6.2 getattr()
   这个内置函数用于返回对象的属性值。
   格式是`getattr(对象名，'属性名'[,Default])`,Default是不存在这个属性的时候返回的默认值，可以设置为None。
+ 6.7 **继承**
   可以为一个自定义的类指定它的父类，这样它就可以共享父类的所有方法。方法就是在定义时在类名后用括号标出父类的名称。

        
## 7 异常
+ 7.1 **异常类**
   | 常见异常类 | 描述|
   |--------|-----|
   | Exception | 是几乎所有异常类的父类 |
   | AttributeError | 引用属性失败|
   | OSError | 操作系统执行异常，如打开文件失败|
   | IndexError| 调用不存在的索引，是LookupError的子类|
   |KeyError | 使用映射中不存在的键，是LookupError的子类|
   | NameError | 找不到变量名|
   | SyntaxError | 代码不正确|
   | TypeError| 将内置操作或函数用于不支持的类型的对象|
   | ValueError | 将内置操作或函数用于类型正确但值错误的对象 |
   | ZeroDivisionError| 除零错误|
   | IndentationError| 缩进错误|

异常类在程序发生异常时会报告。
+ 7.2 **raise语句**  在raise后加异常类，就可以应发相应的异常。  例如` raise Excption`语句，就能唤起一个exception（没有确切含义）异常。

+ 7.3  **捕获异常**
利用**try**语句可以捕获异常。即在try语句下执行的程序如果出了某种特定错误，将不会终止程序，而是执行特定的命令。例如：
  ```python
  try:
    x=int(input("the first number please:"))
    y=int(input("the second number please:"))
    print(x/y)
  except ZeroDivisionError:
    print("The second one can't be zero!")
  ```
   当然，如果捕获了错误，但是在某种情况下要让它继续向上传递，可以调用raise语句，不加任何参数。所谓**向上传递**，就是一个异常如果发生在类里，而类又没有解决该异常的方法，那么类将会把异常提交给调用这个类的语句（可能位于主程序的某个位置），如果主程序也没有捕获它，那么就会引发程序终止，这个过程就是异常的传递。

+ 7.4 多个except子句
  如果要对不同的异常做出不同的处理，可以使用多个except子句。
  如果要对不同的异常做出相同的处理，则要把这些异常类名放在一个元组里，作为except的参数。
  例如：
  ```python
  try:
    x=int(input("the first number please:"))
    y=int(input("the second number please:"))
    print(x/y)
  except ZeroDivisionError:
    print("The second one can't be zero!")
  except TypeError:
    print("It's not a number!")


  try:
    x=int(input("the first number please:"))
    y=int(input("the second number please:"))
    print(x/y)
  except (ZeroDivisionError,TypeError):
    print("程序出了点问题……")
  ```
  注意，这里的元组必须用圆括号括起来。
  对于多个异常，我们可以通过访问异常对象的方式知道到底是哪个异常，如下：
  ```python
  try:
    x=int(input("the first number please:"))
    y=int(input("the second number please:"))
    print(x/y)
  except (ZeroDivisionError,TypeError) as err:
    print("程序出了点问题……")
    print("问题是",err)
  ```
+ 7.5 如果except没有参数，就意味着将捕获所有异常。但是这样一来，我们就不能知道错误到底出在哪里了。因此，更好的办法是捕获Exception类，因为绝大多数异常都是它的子类。
  &nbsp;
  此外，try-except语句也可以有else，即不出现异常时执行的内容。格式如下：
  ```python
  try:
    something interesting
  except:
    something rather interesting
  else:
    something even interesting
  ```  

+ 7.6 **finally**
  finally子句下的内容是无论try中发生什么异常，都会执行finally子句下的内容。

## 8 特殊方法
+ 8.1 **构造函数（constructor）：初始化**
   构造函数就类似于初始化方法，它放在类中，只要为类创建了对象，就会自动调用初始化方法。构造函数写成`__init__` 。例如：
   ```python
   class FooBar:
        def __init__(self):
            print("Hello!")
        def ……
   ```
   如上所示，__init__方法的定义和普通方法没有区别，只不过是自动调用的罢了。
+ 8.2 **重写：修改继承**
  一般而言，子类从父类里继承所有方法，就可以直接调用。当我们要让父类方法在子类的调用时有所不同，可以使用**重写**。
  重写很方便，在子类中重新定义一个同名方法就可以覆盖父类的方法（总是子类方法优先）。
  &nbsp;
  然而，如果重写父类的方法，同时又要用到原来的父类方法（这种情况在使用构造函数__init__时很常见，因为通常需要两遍初始化），怎么办呢？
  在旧版中，可以通过直接在重写的方法里以父类名为对象名调用父类方法。在新版中，应该使用**super函数**。
  ```python
  class A:
    def __init__(self):
        print("Hello")
  
  class B(A):
    def __init__(self):
        super().__init__(self)
        b=None*10
  ```
  这样一来，就可以同时进行两个初始化了。
+ 8.3 **协议**
  序列和映射都是元素的集合，要规定它们的基本行为（协议），对不可变对象要至少实现2个方法，而对可变对象至少需要实现4个。分别如下：
  - `__len__(self)`:该方法返回集合的项数。
  - `__getitem__(self,key)`：返回键key相应的值。
  - `__setitem__(self,key,value)`：把值与键关联起来。只有需要对象可变时才要用到。
  - `__delitem__(self,key)`：删除与key相关联的值。只有需要对象可变（以及可删除）时才要用到。
  &nbsp;
  这些方法是一个序列或者映射必须的，虽然它们不一定都是这些名字。所有内置的序列例如列表，都配备了这些方法。但是在自定义时，如果一个自定义序列或者映射没有足够的基本协议，它就不能算序列或者映射。这也就是说，**多态把所有拥有这些协议的对象都看作是序列或者映射**。
+ 8.4 **从已知类继承**
  如果要在自定义类中实现别的类的方法，就可以直接继承。例如，在自定义的序列中，要用到类似pop的功能，那么就可以让自己的序列直接继承dict类。
  &nbsp;
  类似地，list、str、tuple等都是类名。
+ 8.5 **私密属性**
  - 8.5.1 **property函数**
    property()函数可以让属性限制只能用接口访问。
    例如，现在有属性mark，储存考试分数。然后为这个属性创造了两个接口，一个是修改方法set_mark，一个是获取方法get_mark。修改方法会把分数限制在0-100之间，如果乱输入就会报错。然而，如果有人知道这个程序的内核，他就可以直接修改属性，改成200分也可能出现。
    现在property函数就可以让用户访问属性也必须通过规定方法。
    pproperty()函数的文档写的是property(fget=None, fset=None, fdel=None, doc=None)。
    其中。fget是获取方法，fset是设置方法，fdel是删除方法，doc是文档。也就是这个函数只支持为私有属性设置这些接口，而且并不是所有参数都是需要的。这些参数分别就是该类里面已经定义过的方法名。
  + 8.5.2 **其他方法**
    - `__getattribute__(self,name) `在属性被访问时自动调用
    - `__getattr__(self,name)` 在属性被访问而对象没有这样的属性时自动调用
    - `__setattr__(self,name，value)` 试图给属性赋值时自动调用
    - `__delattr__(self,name)` 试图删除时自动调用

    以上四个方法的内容都可以自定义，可以很好地保证类数据的安全。例如，
    ```python
    class Rectangle:
        def __init__(self):
            self.width=0
            self.height=0
        def __setattr__(self,name,value):
            if name=='size':
                self.width,self.height=value
            else:
                raise AttributeError
    ```

## 9 迭代器和生成器
+ 9.1 **迭代器**
  **迭代**意味着重复多次。所有实现__iter__方法的对象都是**可迭代对象**。在此基础上，实现了__iter__方法和__next__方法的对象都是**迭代器**。一般来说，迭代对象就是能被for循环处理的对象，比如range函数的返回值。
  &nbsp;
  for循环并不知道迭代的对象到底是什么（可能是列表或者自定义的迭代器等等），但是只要检测到__iter__方法，它就可以完成迭代。这就是多态的体现。
  - 9.1.1 **`__iter__`方法**
    这个方法是可迭代对象的基础。它的内容就是返回迭代对象，由于本身就是迭代对象，所以它返回对象本身。如下：
    ```python
    class iterate:
        def __iter__(self):
            return self
    ```
  - 9.1.2 **`__next__`方法**
   从上一个示例可以看出，虽然实现了迭代，但是实际没有任何功能。我们如果要求每次迭代都返回一个值或者做一些改变，那么就要用到__next__方法。这个方法会让迭代器返回下一个值，如果没有什么可以返回了，就会引发StopIteration异常。
    ```python
    class Fibonacci:
        def __init__(self):
            self.a=0
            self.b=1
        def __next__(self):
            self.a,self.b=self.b,self.a+self.b
            if self.a<100:
                return self.a
            else: raise StopIteration
        def __iter__(self):
            return self
   
    fib=Fibonacci()
    for i in fib:
        print(i)
     ```
    **另外，不要忘记构造函数list可以把可迭代对象变成列表**
    &nbsp;
+ 9.2 **生成器**
    生成器就是一种特殊迭代器。
    生成器的新东西是`yield`语句。所有包含yield语句的函数都是生成器。yield会**一个一个**生成值，生成一个值以后就会冻结函数，等待下一次生成。
    生成器和迭代器的首要区别就是，生成器是函数而迭代器一般是类。迭代器需要外部的for循环去迭代它，而生成器可以自己带for循环。两者可以实现相同的功能，不过生成器更加优美。
    
    - 9.2.1 **递归式生成器**
      如果不知道要生成的确切个数，那就应该使用递归，递归的好处就是不用知道到底要循环多少次。
      例如，现在要展开一个多重嵌套的列表[1,2,[1,2],[1,2,[1,2,[1,2,3],4],4,[1,2]],就可以用生成器：
      ```python
      def flatten(nested):
        try:
            for i in nested:
                for j in flatten(i):
                    yield j
        except TypeError:
            yield nested
      ```
      不过，结果是一个迭代器，所以还要对其使用list函数。
      然而，这个函数虽然适用于大部分可迭代对象，却不适用于字符串，因为字符串不存在嵌套。**要判断一个对象是不是字符串，最简单的方法是，尝试将它和另一个字符串拼接，如果不是字符串，就会引发TyprError异常。所以只要判断是否有异常即可。**
## 10 模块
+ 10.1 **将程序导入为模块**
   任何python程序都可以作为模块导入。下面的程序就是例子：
   ```python
   import sys
   sys.path.append('E:/Code/python')
   import ppppy
   ```
   第二行的作用是告诉编译器，如果在默认的模块路径和环境变量里找不到ppppy.py，可以到括号里的文件夹里找。
   模块不能多次导入。如果一定要更新模块，可以使用importlib模块里的reload()函数。这个函数的参数为要重新导入的模块，函数返回重新导入的模块。如下：
   ```python
   import ppppy as pp
   iomport importlib
   pp=reload(pp)
   ```

## 11 文件
+ 11.1 打开文件:open()函数
   open()函数用于打开文件，函数会返回文件对象，基本参数（第一个参数）是文件的绝对路径（如果文件位于当前文件夹则只需写出文件名）。如果找不到文件将会报错：FileNotFoundError。
   &nbsp;
   然而上述方法打开的文件是只读的，如果要求写入，就需要使用参数mode.
   |参数mode的取值|描述|
   |------|-----|
   |'r'|读取模式（default）|
   |'w'|写入模式，若文件不存在就创建一个文件。再该模式下写入，会将文件清空，从头开始写。如果不想删除内容可以使用附加模式|
   |'x'|独占写入模式，必须自己创建一个新文件，如果文件已存在就会报FileNotFoundError|
   |'a'|附加模式
   |'b'|二进制模式（配合其他模式）
   |'t'|文本模式（default）（配合其他模式）
   |'+'|读写模式（配合其他模式）|

   '+'表示既可以读取也可以写入，例如'r+'和'w+'都表示读写。区别在于，前者不会截断文件，而后者会清空文件。
   &nbsp;
   默认参数'rt'，表示把文件视为经过编码的Unicode文本，因此将自动解码和编码，且默认使用UTF-8编码。此外，'rt'还会自动转换换行字符。默认情况下行以'\n'结尾。读取时将自动替换其他行尾字符'\r''\r\n'(见c语言)，写入时将'\n'替换为系统默认行尾字符os.linesep。os.linesep字符串给出当前平台使用的行终止符。例如，Windows使用’\r\n’，Linux使用’\n’而Mac使用’\r’,这使得程序有更好的跨平台性能。
   &nbsp;
   'rb'是二进制模式，适用于非文本文件，例如图片或者视频。

+ 11.2 读取和写入
   读取用read方法，写入用write方法。
   read方法的参数可以指定读取字符数，然后返回它。如果没有参数，read将会从上次结束处（如果刚刚打开则从开头）读取剩下所有字符。文件结尾会返回一个空字符。
   write函数有返回值，在 Python 3 中，write() 函数的返回值是参数data的字节数。在 Python 2 中，其返回值是 None。write的参数可以是文本、二进制等。
   每当调用write(string)时，提供的字符串都将写入到文件中既有的内容后面（无论打开方式是不是'w'）。
  - 11.2.1 seek()和tell()
    方法seek将当前位置（执行读取和写入的位置）移到参数指定的地方。seek的参数有两个：fileObject.seek(offset[,whence])。
    offset:偏移量，代表需要移动偏移的字节数。
    whence:可选，默认值为0，指定偏移的起始位置。0代表从文件开头开始算起（偏移量不能是负数），1代表从当前位置开始算起，2代表从文件末尾算起（后两者偏移量可以是负数）
    &nbsp;
    tell返回当前位于文件的什么位置，没有参数。
  - 11.2.2 读取行和写入行
    要读取一行（从当前位置到下一个分行符的文本），可以用readline方法。这个方法可以不需要参数，此时会读取一行并返回它。也可以提供一个非负整数，指定readline一次可以读取多少字符。
    要读取所有行，并以列表方式返回，可以使用readlines。
    writelines与readlines正相反，接受一个字符串列表（实际上可以是任何可迭代对象），并将它们全部写入文件中，写入时不会添加换行符，所以必须自己添加。
    没有writeline，因为有write。
+ 11.3 关闭文件
  利用close方法可以关闭文件。一般在程序运行结束时会自动关闭文件对象，但是选择及时关闭文件更加安全。
  对于写入过的文件，一定要将其关闭，因为python可能缓冲你写入的数据（将数据暂时存在某个地方，以提高效率）。因此如果程序因为某个原因崩溃，数据可能根本不会写入到文件里。所以使用完文件后及时关闭，可以确保数据安全。
  如果要重置缓存，把缓存中的数据存入目标文件，但又不想关闭文件，可以使用方法flush。
  &nbsp;
  要确保文件被关闭，可以使用一条try/finally语句，在finally语句中调用close。这里的try语句不准备捕获任何异常，只是为了能使用finally语句。
  ```python
  #打开文件
  try：
      #写入数据
  finally：
      file.close()
  ```
  &nbsp;
  实际上，为了不像上面那么繁琐，还可以使用with语句。with语句能打开一个文件并将其赋给一个变量。在语段结束的时候会自动关闭文件。
  ```python
  with open("file.txt") as f:
    do_something
  ```
+ **with语句·**
  with实际上是一个通用结构，允许使用**上下文管理器**。**上下文管理器是支持两个方法的对象：__enter__和__exit__**。
  方法__enter__不接受任何参数，在进入with语句时被调用，其返回值被赋给关键字as后面的变量。
  方法__exit__接受三个参数：异常类型、异常对象和异常跟踪。它在离开方法时被调用（通过前述参数将引发的异常传递给它）。如果__exit__返回False，将抑制所有异常。
  文件也可以用作上下文管理器。它们的写法__enter__返回文件对象本身，而方法__exit__关闭文件。
+ 11.4 文件迭代
  有时需要一个一个地获取文件字符，可以使用while语句：
  ```python
  with open(a_file) as f:
    while true:
        char=f.read(1)
        if not char: break
        print(char)
  ```
  这个语段关键在于read到文件末尾时会返回空字符，此时就能结束循环。
  &nbsp;
  最好的是使用文件迭代器。文件可以直接在for循环中被迭代,不过只能以行为单位迭代：
  ```python
  with open(filename) as f:
    for line in f:
        print(line)
  ```
  或者，如果不写入文件，可以选择让Python自己关闭它：
  ```python
  for line in open(filename):
    print(line)
  ```
+ 11.5 print的重定向
  类似linux，python也可以重定向。
  print重定向有很多方法，例如，因为print本质调用了sys.stdout.write(),所以把文件对象f赋值给sys.stdout，就可以实现将terminal上的内容重定向到文件f中。
  但是在此之后还需要将sys.stdout赋回原值，否则就失去了在terminal上打印的能力，所以实现要先保存sys.stdout的内容。
  以上方法很麻烦，实际上，print可以直接指定重定向的文件：
  ```python
  f=open(filename)
  print("hahh",file=f)
  ```
  可见设置file参数即可实现重定向。
  需要注意的是，print的输出会自动添加换行符\n，writelines则不会。

## 12 数据库支持
+ 12.1 API简介
  DB API是标准数据库接口。对于不同的数据库，python有许多模块，为了统一而使用DB API接口。每个能与DB API 2.0兼容的数据库模块都必须包含三个全局变量：apilevel（Python API版本）、threadsafety（模块的线程安全程度）和paramstyle（参数风格）。
  &nbsp;
  API级别是一个字符串常量，指出了所用API的版本。DB API 2.0要求这个值为'1.0'或'2.0'。如果没有这个变量，就说明与DB API 2.0不兼容，应假定使用的DB API 1.0。
  &nbsp;
  线程安全程度，是一个0~3（含）的整数。0表示线程不能共享模块，3表示模块是绝对线程安全的。
  操作系统会控制计算机交替执行多个进程（同步），例如，在一个进程执行I/O时，cpu就会空闲，此时操作系统控制另一个进程占用cpu。所以尽管进程**独占**cpu，计算机依旧是交替串行进行计算的（对于一个单核cpu来讲如此，多核可以实现真正的并行）。通常一个进程会细分为很多线程，cpu交替处理这些线程，使cpu性能充分发挥。但是，正是这种交替处理的方法造成了线程不安全。操作系统保证每个进程都独占一部分内存，但是一个进程下的线程却并不是内存，通常有一块内存空间是进程内的所有线程都可以访问的，就是**堆内存**。堆内存和cpu的交替处理结合，就会导致问题。例如，一个程序的两个线程共享一个变量i，并且线程内容都是执行i++，假设各自循环1000次，最后我们期望得到的i自然是2000，但是计算机给出的结果可能是小于2000的值。这是因为，i++这个操作其实会被细分为读、算、写三步，有这样一种情况，第一个线程把变量i从内存读取到cpu缓存，这时第二个线程开始独占cpu，它也从内存读取i，然后执行了i++并把i写回内存，然后轮到第一个线程，它既然已经把i读取到缓存中，就会用cpu缓存里的i值计算i++，然后写回内存，这样的情况就浪费了一次i++，最后导致结果偏小和不稳定。
  在这里，i++就是一个线程不安全的操作。如何实现线程安全呢？**线程安全**需要实现原子性、可见性和有序性。**原子性**是指，这个线程像原子（哲学意义上）一样不可分割，不能被打断。**可见性**是指，两个线程共享一个变量，一个线程修改了变量另一个线程要能够立即看到。**有序性**是指，严格按照代码顺序执行任务。对于第三点，按照代码顺序的意思是，程序代码在表达上通常不会是并行的，代码一定是命令过程1先做1000次i++，再命令过程2再做1000次i++，但是由于编译器的动态编译，希望对程序做出优化，通常会修改程序顺序，导致线程并行，然后不明所以的操作系统对并行的线程按照常规处理办法交替运行，导致了线程不安全。
  对于原子性，可以通过对线程加锁的方式实现。而可见性，如果是**不共享的变量**，通常存储于每个线程都独占的**栈内存**上，即使用局部变量。但是按照主流编程语言的规定，**共享变量**必须被分配在公共的堆内存中。对于不同的情况，有不同的方案。如果这个变量在各个线程里不需要相互引用（例如最后在多个线程的运算结果中取最大值作为这个变量的终值，但运算过程可以做到彼此独立），那就让每个线程都拷贝它一份，每个线程只处理自己的这一份拷贝而不去影响别的线程的，当然，这些拷贝出来的变量依旧位于堆内存中，只是做到每个线程一份，互不影响。如果这个变量只是作为常量参与线程，那么可以将其设置为**只读**。如果这个变量需要做到最为复杂的实时共享，而显然cpu和内存是不具备这样实时共享的功能的，因而我们选择为**变量**加上（**互斥）锁**（在java中更为常见）。如果一个线程持有了锁，那么就算cpu空闲了另一个线程也不能访问这个变量。
  但是，因为锁的获取和释放是要花费一定代价的（线程会抢夺锁），如果在线程数目特别少的时候，可能根本就不会有别的线程来操作数据，此时获取锁和释放锁就是一种浪费了，为此专门提出了一种方法，叫CAS（Compare And Swap）。就是在并发很小的情况下，数据被意外修改的概率很低，但是又存在这种可能性，就用CAS。假如一个线程操作数据，进行到一半就不再占用这个变量（可能去执行输出了），于是它记录下当前数据的状态，然后就让出这个内存。回来后打算继续执行，但是数据可能被修改了，于是就把之前保存的数据状态和现在的数据状态进行对比，如果一样，说明数据没有被修改（当然也有可能是先被改成了其它，然后又改回来了，这就是ABA问题了），那就照常继续。如果不一样，说明数据已经被修改了，那就需要从头再重新开始处理一遍。所以CAS这种方式适用于并发量不高的情况，也就是数据被意外修改的可能性较小的情况。如果并发量很高的话，数据一定会被修改，每次都要从头开始，反而比锁花费更大代价。
  


  



   
   



  


        

        


      
     

     
  
  
